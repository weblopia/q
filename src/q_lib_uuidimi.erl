%%%-------------------------------------------------------------------
%%% @author Madalin Grigore-Enescu
%%% @copyright (C) 2017, <Madalin Grigore-Enescu>
%%% @doc
%%% Routines for generating integer monotonically increasing uuid (uuidimi)
%%% @end
%%% Created : 07. Feb 2017 12:04 AM
%%%-------------------------------------------------------------------
-module(q_lib_uuidimi).
-author("madalin").

-include_lib("q/include/q.hrl").

-export([origin/0]).
-export([infinity/0]).

-export([new/1, new/2]).
-export([now/0, now/1]).

-export([get_nanoseconds/1]).
-export([get_microseconds/1]).
-export([get_milliseconds/1]).
-export([get_seconds/1]).
-export([get_datetime/1]).

-export([is_valid/1]).
-export([is_valid_guard/1]).

-export([max/2]).
-export([min/2]).
-export([compare/2]).

-export([order_ascending/1]).
-export([order_ascending/2]).
-export([order_descending/1]).
-export([order_descending/2]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% origin/infinity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc Returns origin monotonically increasing uuid (uuidmi).
%% Origin uuidmi is the 0 reference point in the past for all others time uuidmi generated by our system
origin() -> <<"0">>.

%% @doc Returns infinity uuidmi
%% An infinity uuidmi is a uuidmi so far away in the future that is impossible to be generated by our system in normal operation mode.
infinity() -> <<"99999999999999999999999999999999">>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% new
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @spec new() -> binary()
%% @doc Creates a new uuidmi
new({{Year, Month, Day}, {Hour, Minute, Second}}, Namespace) -> new(q_lib_time:convert_datetime_to_posix_nanoseconds({{Year, Month, Day}, {Hour, Minute, Second}}), Namespace);
new({Year, Month, Day}, Namespace) -> new(q_lib_time:convert_datetime_to_posix_nanoseconds({{Year, Month, Day}, {0, 0, 0}}), Namespace);

%% Guard us creating uuidmi back in the past before Q epoch or very far away in the future
new(Microseconds, _Namespace) when
  Microseconds < ?Q_TIME_NANOSECONDS_Q_EPOCH,
  Microseconds > ?Q_UUIDIMI_MAX_NANOSECONDS -> throw(qwe_time_uuid_invalid_microseconds);
new(Nanoseconds, Namespace) ->

  %% Reduce the length of any Q time uuid by using our own epoch wich starts later than UNIX epoch
  QNanoseconds     = erlang:integer_to_binary(Nanoseconds - ?Q_TIME_NANOSECONDS_Q_EPOCH),

  %% Build unique integer by combining node with namespace
  Unique1 = erlang:integer_to_binary(erlang:phash2(Namespace, 999999999)),
  Unique2 = erlang:integer_to_binary(erlang:phash2(erlang:node(), 999999999)),
  Unique  = <<Unique1/binary, Unique2/binary>>,

  FixedSizeQNanoseconds = q_lib_binaries:prepend_byte_to_size(QNanoseconds, ?Q_UUIDIMI_MAX_NANOSECONDS_LENGTH, 48),
  FixedSizeUnique       = q_lib_binaries:prepend_byte_to_size(Unique, ?Q_UUIDIMI_MAX_UNIQUE_LENGTH, 48),

  <<FixedSizeQNanoseconds/binary, FixedSizeUnique/binary>>.

%% @spec global_new() -> binary()
%% @doc Creates a new Time UUID guaranted to be unique.
now() -> new(q_lib_time:strict_monotonic_nanoseconds(), self()).
now(Namespace) -> new(q_lib_time:strict_monotonic_nanoseconds(), Namespace).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% get
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc Get uuidimi nanoseconds component
get_nanoseconds(<<QNanoseconds:?Q_UUIDIMI_MAX_NANOSECONDS_LENGTH/binary, _/binary>>) ->

  TrimedNanoseconds = q_lib_binaries:trim_left(QNanoseconds, 48),
  erlang:binary_to_integer(TrimedNanoseconds) + ?Q_TIME_NANOSECONDS_Q_EPOCH.

%% @doc Get uuidimi microseconds component
get_microseconds(Uuidimi) -> get_microseconds(Uuidimi) div 1000.

%% @doc Returns uuidimi milliseconds component
get_milliseconds(Uuidimi) -> get_microseconds(Uuidimi) div 1000000.

%% @doc Returns uuidimi seconds component
get_seconds(Uuidimi) -> get_microseconds(Uuidimi) div 1000000000000.

%% @doc Returns gregorian date time touple from the specified uuidmi
get_datetime(Uuidimi) ->

  UnixSeconds       = get_seconds(Uuidimi),
  GregorianSeconds  = UnixSeconds + ?Q_TIME_SECONDS_UNIX_EPOCH,
  calendar:gregorian_seconds_to_datetime(GregorianSeconds).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% is
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @spec is_valid(Uuidimi : term()) -> true | false
%% @doc Check the specified Time UUID to see if it is valid.
is_valid(Term) when is_binary(Term) -> is_valid_iterate(Term, 0);
is_valid(_Term) -> false.
is_valid_iterate(<<>>, ?Q_UUIDIMI_LENGTH) -> true;
is_valid_iterate(<<Byte:1/integer-unit:8, Rest/binary>>, Len) when Byte > 47, Byte < 58 -> is_valid_iterate(Rest, Len+1);
is_valid_iterate(_, _) -> false.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% guards
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @spec is_valid(Uuidimi : term()) -> true
%% @doc Guard the specified Time UUID for validity
is_valid_guard(Uuidimi) -> true = is_valid(Uuidimi).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% comparison
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc Return the largest of Uuidimi1 and Uuidimi2.
%% If the terms compare equal, Uuidimi1 will be returned.
max(Uuidimi1, Uuidimi2) -> q_lib_binaries:max(Uuidimi1, Uuidimi2).

%% @doc Return the smallest of Uuidimi1 and Uuidimi2.
%% If the terms compare equal, Uuidimi1 will be returned.
min(Uuidimi1, Uuidimi2) -> q_lib_binaries:min(Uuidimi1, Uuidimi2).

%% @doc Order a list of time uuid ascending
order_ascending(UuidimiList) -> q_lib_binaries:order_ascending(UuidimiList).

%% @doc Order 2 time uuid ascending
order_ascending(Uuidimi1, Uuidimi2) -> q_lib_binaries:order_ascending(Uuidimi1, Uuidimi2).

%% @doc Order a list of time uuid descending
order_descending(UuidimiList) -> q_lib_binaries:order_descending(UuidimiList).

%% @doc Order 2 time uuid descending
order_descending(Uuidimi1, Uuidimi2) -> q_lib_binaries:order_descending(Uuidimi1, Uuidimi2).

%% @doc Compare two uuid returning 'equal' if they are the same, 'first' if first uuid is the latest one or 'second' if second is the latest one.
compare(Uuidimi1, Uuidimi2) -> q_lib_binaries:compare(Uuidimi1, Uuidimi2).